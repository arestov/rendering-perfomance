<html>
<head>
<meta charset="utf-8">
<style>
body {
	padding:2em;
	width: 40em;
	margin: auto;
}
body img {
	max-width: 100%;
}
</style>
</head>
<body>

<p>С октября 2009 года я занимаюсь разработкой приложения для поиска и прослушивания музыки. Я стремлюсь организовать возможность быстрого взаимодействовия пользователя с интерфейсом, и в качестве одного из средств ускорения взаимодействия использую разные способы для быстрой отрисовки страниц. </p>

<p>Предлагаю ознакомиться со способами, реализованными мной в приложении на системном уровне</p>
<ul>
	<li><!-- МОЖНО ПРОДЕМОНСТРИРОВАТЬ датабайндинг --> Повсемнестное кеширование выборок элементов (<em>$('div.active_part span.highlighter')</em>), атомарные операции по изменению (вместо всеобщей перерисовки, вместо переделывания больших участков DOM дерева)</li>
	<li>Минимизации чтений DOM во время записи изменений состояний </li>
	<li><!-- МОЖНО ПРОДЕМОНСТРИРОВАТЬ прогресс загрузки и проигрывания файла --> Кеширование размеров и расположения элементов (что спасает от излишниго вычисления при считывании этих значений при наличии других изменений - чтение во время изменения множества частей дерева крайне негативно сказывается на производительности)</li>
	<li>Аккуратное, не затягивающееся накопление изменений, необходимых произвести в DOM</li>
	<li><!-- МОЖНО ПРОДЕМОНСТРИРОВАТЬ изменения коллекций --> Прикрепление частей изменяющихся коллекций одним разом (когда, например, в середину списка вставляется 3 новых элемента; <em>createDocumentFragment</em>) в конкретное место (<em>after</em>, <em>before</em>) вместо открепления всей коллекции от DOM и повторного прикрепления (и вместо того, чтобы перерисовывать весь список)</li>
	<li><!-- МОЖНО ПРОДЕМОНСТРИРОВАТЬ изменение коллекций --> Прогрессивный асинхронный рендеринг: картина прорисовывается сразу с небольшим количеством деталей, затем деталей появляется всё больше и больше</li>
	<li>Клонирование нодов (как часть шаблонизации)</li>
	<li>Кеширование и использование кеша результатов парсинга DOM шаблонов</li>
</ul>


<h3>Повсеместное кеширование выборок нодов, атомарные изменения</h3>

Первые оптимизации, сделанные мной самые простое - при изменениях состояний модели не перерисовывать всю вьюху, а изменять лишь часть. Не использовать <em>.innerHTML</em> (или <em>jquery(...).html()</em>). Кэшировать выборки нодов (селекторов), т.е. если мне нужно изменить какую-то часть, то я не делаю выборку каждый раз, а просто беру нужный нод из кеша.

<p>Как это происходит? Например у модели были следующие состояния</p>
<pre>{
  artist: "The Killers",
  track: null
}</pre>
мы изменили их этим кодом:
<pre>track_model.updateState('track', "When You Were Young");</pre>
стали
<pre>{
  artist: "The Killers",
  track: "When You Were Young"
}</pre>


<p>после изменений во View срабатывает функция реагирующая на изменение какого-то конкретного состояния и производит DOM изменения, в данном случае сработает следующий код:</p>
<p>(обратите внимание на название метода - <em>'stch-' + state_name</em> или <em>'stch-track'</em>);</p>



<pre>'stch-track': function(new_state, old_state){
  this.container
    .find('.song-track-name')
    .text(new_state)
    .toggleClass('hidden', !new_state);
}</pre>
Если при каждом изменении делать выборку (<em>this.container.find('.song-track-name')</em>), то это негативно скажется на производительности, поэтому чтобы не делать каждый раз выборку сразу меняем например на такой код:  
<pre>'stch-track': function(new_state, old_state){
  if (!this.track_name_node){
    this.track_name_node = this.container.find('.song-track-name'); 
    // этот же код можно было бы вынести в инициализацию нашей вьюхи
  }
  this.track_name_node.text(new_state).toggleClass('hidden', !new_state);
}</pre>

<p>Позже, когда я начал делать и спользовать свой шаблонизатор, для этого и других случаев я создал дириктиву <em>(&lt;span pv-anchor="track_name_con" class="song-track-name">&lt;/span>)</em> которая указывает, что нод нужно закешировать в хранилище, потому что я буду обращаться к нему вручную (вместо того, чтобы каждый раз писать императивный код <em>this.container.find('.song-track-name')</em>). Таким образом я могу переписать реакцию на изменения следующим образом</p>

<pre>'stch-track': function(new_state, old_state){
  this.tpl.ancs['track_name_con'].text(new_state).toggleClass('hidden', !new_state);
}</pre>
<p>Такие простые изменения обычно описываются другими директивами, а директива <em>pv-anchor</em> использутеся для более сложных изменений (например затрагивающиъ расположение или размер других нодов), для навешивания событий при сложном взаимодействии и других вещей где DOM меняется вручную.</p>

<p><img src="img/rendering.gif" alt=""></p>

<h3>Минимизации чтений DOM во время записи изменений состояний</h3> 


<p>Сейчас существуют удобные и быстродейственные шаблонизаторы в <em>angularjs</em> и <em>Facebook React</em>, а когда я только начинал я не знал о существовании каких-либо удобных шаблонизаторов, делающих эти простые вещи (они тогда вообще были?), поэтому я и не стал использовать какие-либо шаблонизаторы.</p>
<p>Когда код в приложении эвалюционировал, разделился по принципу MVC у меня по прежнему не было шаблонизатора, и все реакции на изменения я описывал вручную так как в примере выше.</p>


<p>Позже я обратил внимание на шаблонизатор в быстро набирающем популярность <em>angularjs</em>, который также производил атомарные изменения (data binding). Но интересно для меня было именно то как привязываются изменения состояний к свойствам элементов. Я взял из <em>angularjs</em> код, отвечающий за парсинг выражений и декларативный способ дата байндинга, который оставляет работающим HTML код. Такой способ описания связи позволяет выполнить браузеру самую сложную часть работы (HTML парсинг), а потом многократно использовать результат.</p>
<pre>&lt;div
  class="user_tag_page usual_page"
  pv-class="lula_page usual_page {{!vmp_show && 'hidden'}}"
>&lt;/div></pre>


<p>В данном примере если у модели нет состояния vmp_show, то у элемента должен быть ещё один класс - "hidden"</p>


<p>Такой способ не только удобен и даёт возможность оптимизаций парсинга, но и даёт потенциал по оптимизации производительности связанных с внесением изменений в DOM. Например при изменении классов элементов. Возможно вы знаете, что метод <em>jQuery(node).addClass('sample-class')</em> прежде чем добавить класс проверяет есть ли такой класс у элемента, т.е. прежде чем произвести запись делает дополнительное чтение (по крайне мере до появления classList api). Но т.к. в шаблонизаторе мы знаем полный набор классов и набор классов который должен быть при текущем состоянии модели (например "<em>lula_page usual_page hidden</em>")  мы можем сразу сделать так:</p>


<pre>node.className = "lula_page usual_page hidden";</pre>


<p>Зная состояния моделей и сооствествующую им DOM структуру читать DOM вообще не нужно (если только ничего не зависит от размеров каких-то других частей). Впрочем конкретно с чтением классов эта вещь может вообще не давать прироста в производительности, но это маленький бонус, получаемый мной от шаблозиратора.</p>




<h3>Кеширование размеров и расположения элементов</h3>

<p>Считывание размеров или расположения элементов вызывает преждевременное вычисление всех других произведённых изменений, поэтому это отличное место для оптимизаций. Для случаев где возможно я использую кеширование. </p>


<p>Например, для установки ширины нодов отображающих текущий прогресс воспроизведения и загрузки я использую не процентное значение ширины, а пиксельное. Для вычисления необходимо знать ширину родительского элемента. Ширина родительского элемента может варьироваться от ширины экрана и полного или одиночного отображения списка найденных файлов.</p>


<p>В данном случае ни от каких других вещей ширина не зависит. Она при одинаковой ширине и режиме отображения списка ширина нода будет всегда одинаковая. Я использую вещи, которые могут влиять на ширину как часть ключа при доступе в хранилище.</p>


<pre>this.getBoxDemension(this.getProgressWidth, 'progress_c-width', window_width, !!p_wmss);</pre>




<p>Первый параметр метода (<em>getProgressWidth</em>) - это просто функция которую сам вызовет метод <em>getBoxDemension</em> если в хранилище нет значения для данного ключа.</p>
<p>Остальные параметры просто складываются в строку. <em>p_wmss</em> в строке станет <em>‘false’</em> или <em>‘true’</em>. В результате ключ может выглядеть например так <em>progress_c-width-1372-false</em> </p>

<p>При изменении ширины окна или режима отображения будет вычислена новая ширина для нового ключа (если такой нет ещё в хранилище), а зависящие от этой ширины части будут автоматически перерисованы</p>

<div>
	<p>
		<img src="img/dem1.png" height="400"><br>
		<em>обычная ширина прогресс бара файла</em>
	</p>
	<p>
		<img src="img/dem2.png" height="400"><br>
		<em>ширина прогресс бара при развернутом списке файлов</em>
	</p>
	<p>
		<img src="img/dem3.png" height="400"><br>
		<em>ширина прогресс бара при другой ширине окна</em>
	</p>
</div>
<p>На самом деле к ключу каждый раз добавляется ещё две строки - это имя позиции (гнезда? слота?) данной вьюхи внутри родительской вьюхи, и тоже самое для родительской вьюхи внутри её родительской вьюхи. Это используются для случаев когда одна и таже вьюха используется в разных местах в связи с чем вычисляемые размеры зависят не только от например ширины экрана и режиме отображения списка файлов, но и где используется вьюха.</p>



<h3>Аккуратное, не затягивающееся накопление изменений необходимых произвести в DOM</h3>


<p>В фреймворке реализован сбор всех состояний в пакет до отправки во вьюхи для состояний модели зависящих от другого состояния и изменяющихся при обновлении этого состояния. Но только у этой модели а не у всего приложения. </p>




<p>При обновлении состояния модели все другие состояния модели зависящение от него будут также автоматически обновлены, а изменения будут собраны в один большой пакет и отправлены во вьюху, чтобы рендеринг проходил в одну итерацию. Вычисления изменений будет происходить до тех пор пока не перестанут появлятся новые изменения, но это будет происхдодить только для данной модели. Изменения состояний зависящих от других моделей (например от нашей обновлённой) в этих моделях будут вычисляться только после того как обновлённая модель отправит изменения в свои вьюхи.</p>


<p>Таким образом реализовано, не затягивающеся на слишком долгое время, накопление изменений состояний.</p>


<p>Чтобы рендеринг происходил в одну итерацию при ручном обновлении нескольких состояний я пользуюсь методом</p>
<pre>.updateManyStates({
  artist: 'artist_224',
  title: 'radnomd title 014'
})
</pre>

<p>вместо того, чтобы выполнить два таких шага</p>
<pre>updateState('artist', 'artist_224')</pre>
<pre>updateState('title', 'radnomd title 014')</pre>




<h3>Прикрепление частей изменяющихся коллекций одним разом (<em>createDocumentFragment</em>) в конкретное место (<em>after</em>, <em>before</em>) вместо открепления всей коллекции от DOM и повторного прикрепления</h3>

<p>При изменении списков список не перерисовывается заново</p>
<p>При изменении списков части DOM связанные с элементами списка не создаются заново, </p>
<p>При изменении списков новая очерёдность DOM элементов списка устанавливается не откреплением полностью от документа, а открелением если нужно и прикреплением изменивших свою позицию (или новых элементов) в своё конкретное место.</p>
<p>DOM соотвествующий элементам списка, которые нужно прикрепить, прикрепляется не по отдельность, а с помощью <em>createDocumentFragment</em>, если элементы идут друг за другом. Элементы прикрепляются к <em>documentDrafment</em> в нужном порядке, потом <em>documentDrafment</em> прикрепляется к документу в нужное место с помощью методов <em>after</em>, <em>before</em> ну или <em>append</em></p>


<p>Таким образом при измении списка в DOM происходят только самые необходимые минимальные изменения</p>


<h3>Прогрессивный асинхронный рендеринг: картина прорисовывается сразу с небольшим количеством деталей, затем деталей появляется всё больше и больше</h3>
<p>При необходимости отрисовать большую структуру с вложенными друг в друга элементами (даже простые вещи чаще всего реализованы как вложенные части) в том числе при необходимости отрисовать список фреймворк в первой итерации отрисует вьюхи для моделей находящихся на самом верху структуры, внутри этой итерации будет ещё две: юудет отрисована самая основа, задающая визуальные габариты, далее будут отрисованы детали (касающиеся непосредственно этой модели - реакции на изменения её состояний). В следующий итерации фреймворк будет рисовать вложенные модели и так пока вложенность не кончиться. Все итерации разделены и могут быть разряжены с помощью <em>setTimeout</em>, если отрисовка занимает например более 200 мс (в будущем планирую заменить на requestAnimationFrame), чтобы не блокировать интерфейс и позволить браузеру отрисовать то, что уже есть и для пользователя интерфейс изменялся постепенно, т.е. он видел, что происходят некие изменения, в отличие от более простого способа, когда после продолжительной паузы (в течении которой баузер не реагирует на нажатия и отображает одно и тоже) браузер резко меняет картинку.</p>


<p>Это похоже на прогрессивный jpeg или может напомнить вам игровые движки, в моменты когда движку не хватает ресурсов и изображение появлятся сначала в ужасном качестве (нефильтрованные текстуры, малополигональные модели и т.д) а потом картинка улучшается.</p>
<p><img src="img/rendering2.gif" alt=""><em>Прогрессивный рендеринг: сначала гарабиты, потом детали. Словить момент и запечатлись певрую часть удалось только в режиме отладки, отчего видно затемненеие</em></p>



<h3>Клонирование нодов</h3>

<p>Получение DOM структуры для View происходит примерно следующим образом: HTML парсер самого браузера один раз разбирает HTML (выполняет самую тяжелую работу, это происходит предварительно, во время загрузки всей страницы), далее при необходимости результат клонируется через DOM API (<em>.cloneNode()</em>). Экземляры из шаблона создаются путём клонирования DOM дерева шаблона, после чего читаются и разбираются директивы связанные с этим нодом.</p>

<h3>Кеширование и использование кеша результатов парсинга DOM шаблонов</h3> 


<p>Чтобы после клонирования нодов не приходилось повторно читать атрибуты для поисках директив (такие сервисные данные не копируются при клонировании нода), а так же для повторного использования объектов которые создаются директивами (для последующего использования шаблонизатором) для того, чтобы эффективнее использовалась память и реже срабатывал garbadge collector было найдено решение, которое позволяет максимально быстро копировать сервисные данные из нода-оригинала в нод-клон.</p>

<p>Происходит это следующим образом: шаблонная DOM структура парсится, анализируется. Всем нодам элементов с директивами устанавливается свойство <em>pvprsd</em> с уникальным значением соответствующее уникальному набору директив, который сохраняется в хранилище и может быть использован в будущем. После того как всем нужным элементам установлено свойство, начиная от корня структура ракладывается в массив. Шаблонная структура клонируется от корня, и этот экземляр тоже клонируется. Эксемпляр также от конря раскадывается в массив. Такое клонирование и раскладывание гарантирует, что в масивах под одними индексами будут абсолютно аналогичные ноды. После этого обычная проход по массиву копирует <em>pvprsd</em> из элемента первого массива в элемент массива экземпляра</p>


<pre>
var getAll = function(node) {
  var result = [];
  var iteration_list = [ node ];
  var i = 0;
  while( iteration_list.length ){
    var cur_node = iteration_list.shift();
    if ( cur_node.nodeType != 1 ){
      continue;
    }
    for ( i = 0; i &lt; cur_node.childNodes.length; i++ ) {
      iteration_list.push( cur_node.childNodes[i] );
    }
    result.push( cur_node );
  }
  return result;
};
</pre>
<pre>
var cloned = this.onode.cloneNode(true);
var all_onodes = getAll(this.onode);
var all_cnodes = getAll(cloned);
</pre>
</body>
</html>